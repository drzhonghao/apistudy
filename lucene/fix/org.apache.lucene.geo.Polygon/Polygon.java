

import java.text.ParseException;
import java.util.Arrays;
import org.apache.lucene.geo.GeoUtils;


public final class Polygon {
	private final double[] polyLats;

	private final double[] polyLons;

	private final Polygon[] holes;

	public final double minLat;

	public final double maxLat;

	public final double minLon;

	public final double maxLon;

	public Polygon(double[] polyLats, double[] polyLons, Polygon... holes) {
		if (polyLats == null) {
			throw new IllegalArgumentException("polyLats must not be null");
		}
		if (polyLons == null) {
			throw new IllegalArgumentException("polyLons must not be null");
		}
		if (holes == null) {
			throw new IllegalArgumentException("holes must not be null");
		}
		if ((polyLats.length) != (polyLons.length)) {
			throw new IllegalArgumentException("polyLats and polyLons must be equal length");
		}
		if ((polyLats.length) != (polyLons.length)) {
			throw new IllegalArgumentException("polyLats and polyLons must be equal length");
		}
		if ((polyLats.length) < 4) {
			throw new IllegalArgumentException("at least 4 polygon points required");
		}
		if ((polyLats[0]) != (polyLats[((polyLats.length) - 1)])) {
			throw new IllegalArgumentException(((((("first and last points of the polygon must be the same (it must close itself): polyLats[0]=" + (polyLats[0])) + " polyLats[") + ((polyLats.length) - 1)) + "]=") + (polyLats[((polyLats.length) - 1)])));
		}
		if ((polyLons[0]) != (polyLons[((polyLons.length) - 1)])) {
			throw new IllegalArgumentException(((((("first and last points of the polygon must be the same (it must close itself): polyLons[0]=" + (polyLons[0])) + " polyLons[") + ((polyLons.length) - 1)) + "]=") + (polyLons[((polyLons.length) - 1)])));
		}
		for (int i = 0; i < (polyLats.length); i++) {
			GeoUtils.checkLatitude(polyLats[i]);
			GeoUtils.checkLongitude(polyLons[i]);
		}
		for (int i = 0; i < (holes.length); i++) {
			Polygon inner = holes[i];
			if ((inner.holes.length) > 0) {
				throw new IllegalArgumentException("holes may not contain holes: polygons may not nest.");
			}
		}
		this.polyLats = polyLats.clone();
		this.polyLons = polyLons.clone();
		this.holes = holes.clone();
		double minLat = Double.POSITIVE_INFINITY;
		double maxLat = Double.NEGATIVE_INFINITY;
		double minLon = Double.POSITIVE_INFINITY;
		double maxLon = Double.NEGATIVE_INFINITY;
		for (int i = 0; i < (polyLats.length); i++) {
			minLat = Math.min(polyLats[i], minLat);
			maxLat = Math.max(polyLats[i], maxLat);
			minLon = Math.min(polyLons[i], minLon);
			maxLon = Math.max(polyLons[i], maxLon);
		}
		this.minLat = minLat;
		this.maxLat = maxLat;
		this.minLon = minLon;
		this.maxLon = maxLon;
	}

	public double[] getPolyLats() {
		return polyLats.clone();
	}

	public double[] getPolyLons() {
		return polyLons.clone();
	}

	public Polygon[] getHoles() {
		return holes.clone();
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = (prime * result) + (Arrays.hashCode(holes));
		result = (prime * result) + (Arrays.hashCode(polyLats));
		result = (prime * result) + (Arrays.hashCode(polyLons));
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if ((this) == obj)
			return true;

		if (obj == null)
			return false;

		if ((getClass()) != (obj.getClass()))
			return false;

		Polygon other = ((Polygon) (obj));
		if (!(Arrays.equals(holes, other.holes)))
			return false;

		if (!(Arrays.equals(polyLats, other.polyLats)))
			return false;

		if (!(Arrays.equals(polyLons, other.polyLons)))
			return false;

		return true;
	}

	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < (polyLats.length); i++) {
			sb.append("[").append(polyLats[i]).append(", ").append(polyLons[i]).append("] ");
		}
		if ((holes.length) > 0) {
			sb.append(", holes=");
			sb.append(Arrays.toString(holes));
		}
		return sb.toString();
	}

	public static Polygon[] fromGeoJSON(String geojson) throws ParseException {
		return null;
	}
}

